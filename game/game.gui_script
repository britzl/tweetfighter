local flow = require "ludobits.m.flow"
local events = require "game.events"

local MAX_VALUE = 10



local world_position
world_position = function(node, pos)
	pos = pos or vmath.vector3()
	local parent = gui.get_parent(node)
	if parent then
		return world_position(parent, pos + gui.get_position(node))
	end
	return pos
end


local function lerp(a, b, t)
	return a + (b - a) * t
end


local function progressive(from, to, duration, cb)
	flow(function()
		local start = socket.gettime()
		while true do
			local now = socket.gettime()
			local t = (now - start) / duration
			if t > 1.0 then
				break
			end
			local v = lerp(from, to, t)
			cb(v)
			flow.frames(1)
		end
		cb(to)
	end)
end


local function countup(self, node, from, to, duration)
	progressive(from, to, duration, function(v)
		gui.set_text(node, ("%.1fK"):format(v / 1000))
	end)
end


local function printout(self, node, message, duration)
	progressive(1, #message, duration, function(v)
		gui.set_text(node, message:sub(1, math.ceil(v)))
	end)
end


local function blink(self, node, count, interval)
	timer.seconds(interval or 0.5, function()
		gui.set_enabled(node, not gui.is_enabled(node))
		if count >= 0 then
			blink(self, node, count - 0.5, interval)
		end
	end)
end

local function hide_tweet(self, tweet, duration, delay)
	gui.animate(tweet.root, gui.PROP_POSITION, tweet.position + tweet.hidden, gui.EASING_INQUAD, duration or 1, delay or 0)
end


local function show_tweet(self, tweet, message, duration, delay)
	gui.set_text(tweet.comments, "-")
	gui.set_text(tweet.retweets, "-")
	gui.set_text(tweet.likes, "-")
	gui.set_text(tweet.message, message)
	gui.set_position(tweet.root, tweet.position + tweet.hidden)
	gui.animate(tweet.root, gui.PROP_POSITION, tweet.position, gui.EASING_OUTQUAD, duration or 1, delay or 0)
end


local function new_event(self, event)
	msg.post(".", "acquire_input_focus")
	self.current_event = event
	gui.set_text(self.event_message, "")
	gui.set_text(self.event_messenger, event.messenger .. ":")
	gui.play_flipbook(self.event_image, event.image)
	gui.set_position(self.event_root, self.event_position + vmath.vector3(1000, 0, 0))
	gui.animate(self.event_root, gui.PROP_POSITION, self.event_position, gui.EASING_OUTQUAD, 1, 0, function()
		printout(self, self.event_message, event.message, 1)
		for i=1,2 do
			local tweet = self.tweets[i]
			show_tweet(self, tweet, event.tweets[i].message, 1, 0.5)
		end
	end)
end


local function hide_event(self, duration, delay, cb)
	gui.animate(self.event_root, gui.PROP_POSITION, self.event_position - vmath.vector3(1000, 0, 0), gui.EASING_INQUAD, duration or 1, delay or 0, cb)
end


local function is_game_over(self)
	for i = 1, 4 do
		if self.values[i] == 0 then
			return true
		end
	end
	return false
end

local function update_values(self, change)
	for i = 1, 4 do
		if change[i] ~= 0 then
			local v = self.values[i]
			local value_before_change = v.value
			v.value = v.value + change[i]
			v.value = math.min(v.value, MAX_VALUE)
			v.value = math.max(v.value, 0)
			if value_before_change ~= v.value then
				local size = vmath.vector3(v.size)
				local ratio = v.value / MAX_VALUE
				size.x = size.x * ratio
				gui.set_size(v.bar, size)
				gui.play_flipbook(v.bar, ratio > 0.2 and hash("BAR-BLUE-9SLICE") or hash("BAR-RED-9SLICE"))
				blink(self, v.title, 3, 0.5)
			end
		end
	end
end


local function send_tweet(self, tweet_id, hide_id)
	msg.post(".", "release_input_focus")
	local tweet = self.tweets[tweet_id]
	local world_pos = world_position(tweet.button)
	local arm_pos = gui.get_position(self.arm)
	gui.animate(self.arm, gui.PROP_POSITION, world_pos, gui.EASING_OUTQUAD, 0.5, 0, function()
		gui.animate(self.arm, gui.PROP_POSITION, arm_pos, gui.EASING_INQUAD, 0.5, 0.25)
		gui.play_flipbook(tweet.button, hash("tweet_click"))
		timer.seconds(0.25, function()
			hide_tweet(self, self.tweets[hide_id], 1, 0)
			countup(self, tweet.comments, 0, math.random(10000, 200000), 1)
			countup(self, tweet.retweets, 0, math.random(10000, 200000), 1)
			countup(self, tweet.likes, 0, math.random(10000, 200000), 1)
			update_values(self, self.current_event.tweets[tweet_id].values)
			hide_tweet(self, tweet, 1, 1)
			hide_event(self, 1, 1, function()
				msg.post("#", "new_event")
			end)
		end)
	end, gui.PLAYBACK_ONCE_FORWARD)
end


function init(self)
	self.days = 0

	self.events = events.new_game()

	self.values = {}
	for i=1,4 do
		self.values[i] = {
			value = MAX_VALUE,
			title = gui.get_node("value" .. i .. "/title"),
			bar = gui.get_node("value" .. i .. "/bar"),
			size = gui.get_size(gui.get_node("value" .. i .. "/bar_bg")),
		}
	end
	
	self.tweets = {
		{
			root = gui.get_node("tweet1/root"),
			hidden = vmath.vector3(-1000, 0, 0),
			position = gui.get_position(gui.get_node("tweet1/root")),
			message = gui.get_node("tweet1/message"),
			button = gui.get_node("tweet1/button"),
			comments = gui.get_node("tweet1/comments"),
			retweets = gui.get_node("tweet1/retweets"),
			likes = gui.get_node("tweet1/likes"),
		},
		{
			root = gui.get_node("tweet2/root"),
			hidden = vmath.vector3(1000, 0, 0),
			position = gui.get_position(gui.get_node("tweet2/root")),
			message = gui.get_node("tweet2/message"),
			button = gui.get_node("tweet2/button"),
			comments = gui.get_node("tweet2/comments"),
			retweets = gui.get_node("tweet2/retweets"),
			likes = gui.get_node("tweet2/likes"),
		},
	}

	self.event_root = gui.get_node("event")
	self.event_position = gui.get_position(self.event_root)
	self.event_image = gui.get_node("event_image")
	self.event_message = gui.get_node("event_message")
	self.event_messenger = gui.get_node("event_messenger")
	self.arm = gui.get_node("arm")

	for i=1,2 do
		local tweet = self.tweets[i]
		gui.set_position(tweet.root, tweet.position + tweet.hidden)
	end

	math.randomseed(os.time())
	msg.post("#", "new_event")
end

function update(self, dt)
	flow.update(dt)
end

function on_message(self, message_id, message, sender)
	if message_id == hash("new_event") then
		--local event = table.remove(self.events, 1)
		local event_id = math.random(1, #self.events)
		local event = self.events[event_id]
		new_event(self, event)
	end
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.released then
		if gui.pick_node(self.tweets[1].button, action.x, action.y) then
			print("tweet1")
			send_tweet(self, 1, 2)
		elseif gui.pick_node(self.tweets[2].button, action.x, action.y) then
			print("tweet2")
			send_tweet(self, 2, 1)
		end
	end
end

function on_reload(self)
	-- Add input-handling code here
	-- Remove this function if not needed
end
